\section{Iteration 3: Decomposition of the Measurements Database Scheduler}
\label{add:it3}

\subsection{Step 1: Identify candidate drivers}
\label{add:it3/drivers}

\npar Remote measuring is the core business of the ReMeS system. Almost all
components in the ReMeS system need access to the measurements database.
However, not all queries on that database should be treated equally. For
instance, research queries have a lower priority than anomaly detection history
queries (see P3). Therefore, queries to the measurements database need to be
scheduled.

\npar The decomposition of this iteration is driven by

\begin{itemize}
	\item P3': Requests to the measurements database: These queries are subjected
	to a maximal execution time based on the SLA. 
\end{itemize}

\npar The use cases delegated to this component are

\begin{itemize}
  \item UC8':
  \begin{itemize}
  	\item measurements have to be stored.
  \end{itemize}
  \item UC17': 
  \begin{itemize}
  	\item researchers should be able to extract research data from the database
  	(i.e. perform a read query).
  \end{itemize}

\end{itemize}

\subsection{Step 2: Choose design concepts}
\label{add:it3/concepts}

\subsubsection{Tactics}
\label{add:it3/tactics}

% TODO detection?

\npar The scheduler was introduced in iteration 1 (see section \ref{add:it1}) to
improve performance. At the level of the scheduler, performance is determined by
the scheduling policy. 

\npar The scheduling policy is defined by the quality attributes but the
scheduler itself can be implemented in different ways. One could use a single
queue for the scheduler. Jobs are pushed on a queue and popped off when the
scheduler can process a new job. 

\npar A scheduler can also be implemented with multiple queues. For each kind of
job, there is a seperate queue. In this case, you would end up with a number of
queues for different priorities. Whenever a job resides in a queue for a long
time, it is promoted to a higher priority queue. 

\npar A scheduler must also guarantee that there will be no starvation among
jobs. Starvation happens when a job cannot execute because there always is a
job with a higher priority. When using a first in, first out policy, starvation
will not occur. However, when the database goes into overload mode, this might
become an issue. 

\npar To address this issue, a dynamic priority scheme will be used. The
priority of every job will be increased periodically. In this way, low priority
jobs will eventually have a high priority. 

\subsubsection{Design Patterns}
\label{add:it3/patterns}

\paragraph{Collections for States}

\npar The collections for states design pattern describes a way to efficiently
implement a scheduler with multiple queues. In a client, every state is
represented by a collection of objects with that state. The collections for
each state would be implemented with queues and the the states would represent
priority levels.

\paragraph{Strategy}

\npar If the scheduler allows for multiple policies, the strategy design pattern
can be used to implement these policies. The behaviour of the message router
will be determined by the policy.

\paragraph{Monitor} 

\npar Because the queues can be accessed by both the scheduler and the message
router, monitors have to be put in place to provide synchronization. This is
done to make sure that there aren't any concurrency issues within the scheduler. 

\paragraph{PriorityQueue}

\npar This is not a design pattern but a data type. This queue allows elements
to be inserted with a given priority. This could simplify the design by merging
all queues into one big queue.

\npar There is not really an advantage in having multiple queues. There is only
one instance that can process the jobs. The overhead of comparing the top
entries of the queues might also be large, making this solution less efficient. 

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it3/elements}

%      |
%      schedule(QueryCommand):void
%      |
%      v
%    [Scheduler]
%      |
%      schedule(QueryCommand,PriorityQueue):void
%      |
%      v
%    [PriorityQueue]
%      |
%      enqueue(QueryCommand):void
%      |
%      v
%    [Policy]
%      ^
%      |
%      pop() : Query
%      |
%   [QueueReader]
%      |
%      execute(QueryCommand):void
%      |
%      v
%   [TrameStorage]

\npar The decomposition of this component is shown in figure
\ref{fig:it3/elements}. 

\begin{figure}[H]
	\begin{centering}
		%\includegraphics[width=0.8\textwidth]{figs/add/it3/elements.pdf}
		\caption{Overview of the instantiated child components of the Trame Storage
		Scheduler.}
		\label{fig:it3/elements}
	\end{centering}
\end{figure}

\npar All requests to the Measurements Database Scheduler are encapsulated as
QueryCommand objects. These objects have already been created in another
component and represent a query to the measurements database. Because the
scheduling makes communication asynchronous, the QueryCommand contains a
Callback to return the result of the query to the issuer.

\npar The scheduler (MeasurementsScheduler) handles every incoming command
(QueryCommand) by inserting the command in a queue (MeasurementsQueue) with a
certain priority using a policy (MeasurementsPolicy). The scheduling policy
determines the priority of the command based on the nature of that command. The
priorities of all other commands are increased every time a new command is
inserted. This is done to prevent starvation.

\npar An additional component (MeasurementsQueueReader) will pop the command
with the highest priority off the queue and present it on the database for execution. 

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it3/interfaces}

\subsubsection{MeasurementsScheduler}

\npar The MeasurementsScheduler provides an interface
\interface{MeasurementSchedulerAPI}. This interface contains a method
\method{shedule(QueryCommand) : void} to schedule new commands.

\subsubsection{MeasurementsPolicy}

\npar The QueryCommand will be placed in the MeasurementsQueue by a policy.
Therefore, MeasurementsPolicy provides an interface
\interface{MeasurementsPolicyAPI} which contains a method
\method{insertCommand(QueryCommand) : void}.

\subsubsection{MeasurementsQueue}

\npar The MeasurementsQueue must provide methods for inserting items and
removing items. These methods are contained in the
\interface{MeasurementsQueueAPI} and are called
\method{insertCommand(QueryCommand, priority : Double) : void} and
\method{remove() : QueryCommand}. The first method is used by the
MeasurementsPolicy and the last one is used by the MeasurementsQueueReader.

\npar Figure \ref{fig:it3/interfaces} summarizes the components and the
interfaces instantiated in this iteration.

\begin{figure}[H]
	\begin{centering}
		%\includegraphics[width=0.8\textwidth]{figs/add/it3/interfaces.pdf}
		\caption{Overview of the interfaces and components of the Measurements Storage
		Scheduler}
		\label{fig:it3/interfaces}
	\end{centering}
\end{figure}

\subsection{Step 5: Verify and refine}
\label{add:it3/verification}

% TODO Verify na herziening drivers.

\npar All quality and functionality is handled in this decomposition.  

\begin{itemize}
	\item P1': Timely propagation of alarm trames is handled by smart Queue
	insertion by the Message Router. 
	\item P2': Timely propagation of measurement trames is also handled by smart
	Queue insertion by the Message Router. 
	\item P3': Potential prioritization of certain database queries. 
\end{itemize}