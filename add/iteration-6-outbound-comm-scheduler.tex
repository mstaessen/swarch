\section{Iteration 6: Decomposition of the Outbound Communication Scheduler}
\label{add:it6}

\subsection{Step 1: Identify candidate drivers}
\label{add:it6/drivers}

\npar It is crucial that ``shut down valve" trames are sent in time to the
correct module considering that trames that arrive too late can ultimately
lead to a potential disaster claiming the lifes of several people. Therefore the
outbound trames (i.e. towards modules) need to be scheduled. 

\npar The (only) driver of this iteration is 

\begin{itemize}
  	\item P1': Timely closure of valves.
  	\begin{itemize}
  		\item Alarm trames have to be handled within a bounded time. 
    \end{itemize}
\end{itemize}

\npar No use cases were delegated to this scheduler.

\subsection{Step 2: Choose design concepts}
\label{add:it6/concepts}

\npar The design concepts for this decomposition are exactly the same as those
of the storage and anomaly detection scheduler, see sections
\ref{add:it3/concepts} and \ref{add:it5/concepts}.
This is a logical result considering that both schedulers are established with
performance drivers in mind.

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it6/elements}

\begin{figure}[H]
	\begin{centering}
		% TODO Figure
		%\includegraphics[width=0.6\textwidth]{figs/decomposition/outbound-comm-scheduler/decomposition.pdf}
		\caption{The decomposition of the Outbound Communication Scheduler}
		\label{fig:add/it6/decomposition}
	\end{centering}
\end{figure}

\subsubsection{OutboundCommScheduler}

% TODO paste from other sched
\npar The message router will dispatch incoming trames to the correct queue
based on the importance of the trame and the current policy (the latter is
determined by the system load). 

\subsubsection{OutboundCommPolicy}

% TODO paste from other sched
\npar The task of this component is twofold. First of all it does the actual
scheduling. This means that it pops elements out of the priorityqueue to
redirect for further processing (this off course occurs only when the database
is not processing another trame). Second of all, to prevent starvation
priorities are periodically boosted.

\subsubsection{OutboundCommQueue}

% TODO paste from other sched
\npar This component represents a multilevel queue. When one keeps the indeces
of the last element of every possible priority, it is easy to insert new trames
according to the current policy and the priority of the trame itself.

\subsubsection{OutboundCommQueueReader}

% TODO paste from other sched

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it6/interfaces}

\subsubsection{OutboundCommScheduler}

\paragraph{OutboundTrameScheduler}

\npar The OutboundTrameScheduler was already discussed in section
\ref{add:it1/interfaces}.

\subsubsection{Scheduler}

\npar This component offers no interface.

\subsubsection{PriorityQueue}

\paragraph{OutboundQueue}

\npar This interface is analogous to the priorityqueue interface of the storage
scheduler, see section \ref{add:it3/interfaces}. It offers a \method{pop(trame)}
and \method{push{trame}} method which will respectively pop and push a given
trame from the priorityqueue.

\subsection{Step 5: Verify and refine}
\label{add:it6/verification}

\npar The driver for this iteration, P1, is resolved.