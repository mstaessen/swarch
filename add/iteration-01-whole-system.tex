\section{Iteration 1: Decomposition of the whole system}
\label{add:it1}

\npar In the first iteration, the whole system, ReMeS is decomposed. It takes
all the requirements and quality attribute scenarios as input.

\subsection{Step 1: Identify candidate drivers}
\label{add:it1/drivers}

\npar First of all when designing a decomposition for the whole system, the
choice of the drivers is very imortant since it will shape the architecture the
most. Therefore not only is the priority of the client for each quality
attribute scenario taken into account to choose the drivers, but also the impact of
that scenario on the architecure. These impacts are, together with the client
priorities, summarized in table \ref{table:add/it1/priorities}.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{Quality}			&	Av1	&	Av2	&	Av3	&	P1	&	P2	&	P3	&	M1	&	M2	&	M3	\\
		\hline
		\textbf{Client Priority}	&	H	&	M	&	L	&	H	&	M	&	M	&	H	&	L	&	M	\\
		\hline
		\textbf{Architecture Impact}&	M	&	H	&	L	&	H	&	H	&	M	&	M	&	L	&	M	\\
		\hline
		\end{tabular}
		\caption{Overview of the priorities that are taken into account when
		selecting the architectural drivers}
		\label{table:add/it1/priorities}
	\end{center}
\end{table}

\npar Because this is the first iteration of the architecture design process,
the quality atttributes that will have the most impact on the architecture
are selected. This results in the selection of
\begin{itemize}
  	\item Av1: The measurements database should be separated from other storage. 
  	\item Av2: Components must be able to detect problems autonomously.
  	\item P1: Valves must be shut in time (processing of alarms and remote
  	actuation of valves).
  	\item P2: Process measurement trames in time. 
\end{itemize}

\npar The choice of P1 is logical because it has the highest priority available
(both a high client priority and impact on the architecture). The reasons for
selecting P2, Av1 and Av2 are more subtle because these were mainly selected
because of details in their quality description.

\npar Av1 is selected because it clearly states that the measurement storage
should fail independently from other storage and it has a high client priority. 

\npar Av2 is selected because it requires uptime monitoring of all internal
components. This is a high impact on the architecture. 

\npar P2 is selected because it is related to P1 (and vice versa) and because it
has a high impact on the architecture. 

\npar Based on the architectural drivers, the remote module subsystem has to
provide functionality for remote module communication (receiving and sending
trames), trame storage, trame processing and communication towards stakeholders
(customers, alarm recipients, emergency services, ReMeS personnel).

\subsection{Step 2: Choose design concepts}
\label{add:it1/concepts}

\npar In this section there will be an overview of the chosen tactics and
patterns.

\subsubsection{Tactics}
\label{add:it1/tactics}
 
\npar After selecting the drivers for the current decomposition, one has to
choose the tactics to achieve them. Recall from section \ref{add:it1/drivers}
that two categories of drivers were selected: availability and performance. All
approaches to maintain availability involve either detection, recovery or
prevention of faults. Approaches to maintain performance involve resource
arbitration, resource management and resource demand.
 
\paragraph{Availability}

\npar First of all, a fault needs to be detected. For this, there are three
options: ping/echo, heartbeat and exceptions. It is important to notice that the
latter is not very practical in this case. This can be illustrated with a simple
example.

\npar Suppose that a component $c_1$ depends on another component $c_2$. For
some reason, $c_1$ does not need the services of $c_2$ for a duration longer
than the detection interval of one minute (see Av2). Within this time, no
detection (through exceptions) can occur, simply because there is no interaction
between the components. For this reason, we eliminate exceptions as a primary
fault detection system. However, exceptions will still have to be implemented in
order to make the system fail gracefully (a component being unavailable will not
cause the system to crash).

\npar Another detection method uses ping/echo. This primarily focusses on
network connectivity and will not check the availabillity of the service itself.
Again, this is not very practical. A server can be reachable, but the service on
a certain port number may be unavailable. In this case, the ping/echo
method would not detect the fault.

\npar Heartbeat on the other hand, will be part of the system itself and will be
able to check whether the service is still up and running. It will periodically
(at most every one minute) check the state of the system and send out a pulse
to a heartbeat monitor if everything is runnning fine.

\npar Another advantage of using heartbeat is that the pulse can contain data,
more specifically status data. For instance, a single failing disk in a RAID5
array can cause a warning but will not cause the system to crash. This
information can be included in the pulse of the heartbeat to inform the
administrators to replace the failing disk.

\npar As a result, heartbeat seems the best solution to detect faults.

\paragraph{Performance}

\npar For performance tactics there are three categories: resource
arbitration, resource management and resource demand.

\npar If there is more than one request to gain control over a resource, there
has to be some sort of scheduling put in place. By far the most used one is a
priority scheduler where requests are served earlier when they have a higher priority.
This is particulary useful for alarms to still reach the appropriate parties in
time even when the system is in overload mode. 

\npar Secondly there is resource management. To process more than one trame at a
time, concurrency can be introduced. This can be done in various ways. Several
threads can be started on one processor, on separate processors or even on
separate systems. Another possibilitiy is off course increasing the available
hardware but since this is not a very cost effective solution, this is left out
of consideration.

\npar On a lower level one could also try to minimize network overhead by
only sending small amounts of data in each trame. This is achieved by
limiting the size of the trames to 160 bytes. Compared to modern technology
bandwidths, this size won't be a problem. 

\subsubsection{Design Patterns}
\label{add:it1/patterns}

\paragraph{Active Object}

\npar With respect to resource arbitration and resouce management, the
\emph{Active Object} design pattern \citep[see][p.~365q]{Buschmann:07} is chosen
for trame storage and trame processing. Scheduler policies will determine the
order in which trames are stored, processed and sent.

\paragraph{Strategy}

\npar The previously mentioned schedulers will have different scheduling
policies, implemented with the \emph{Strategy} design pattern, in order to
allow replacement of policies at runtime.

\paragraph{Layers}

\npar Because Remote Modules have vendor specific trame formats and interfaces,
an abstraction layer should be placed between the Remote Modules and the ReMeS
system, especially for the trame storage and processing.

\begin{figure}[H]
	\begin{centering}
		\includegraphics[width=1.2\textwidth,angle=90]{figs/add-it1-elements.pdf}
		\caption{Overview of the instantiated child elements in the ReMeS system}
		\label{fig:it1/elements}
	\end{centering}
\end{figure}

\paragraph{Resource Pool}

\npar To allow load balancing (and hence increase the performance) multiple
instances of the anomaly detection are created. This can be achieved by using
the \emph{Resource Pool} design pattern \citep[see][p.~503]{Buschmann:07}. 

\paragraph{Shared Repository}

\npar The measurements storage is separated from other storage because of Av1.
Still, the remaining storage contains diverse data, user data, remote module
configuration data, etc. Therefore, the \emph{Shared Repository} design pattern
\citep[see][p.~202]{Buschmann:07} will be used to model the other storage.

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it1/elements}


\subsubsection{Remote Module Communication unit}

\npar This module is responsible for all communication from and to remote
modules (all types of communication and both valves and control devices).
Incoming measurements (from remote devices) are handed over to the Scheduler For
MeasurementsStorage. Alarms are dispatched to the Scheduler For Anomaly
Detection. Trames which need to be sent to remote modules are dispatched to the
correct module through the correct medium.

\subsubsection{Scheduler For MeasurementsStorage}

\npar This scheduler gets all incoming queries from the Remote Module
Communication Unit and Scheduler For Anomaly Detection and schedules them for
storage. Dependent on the active scheduling policy queries can be prioritized
over other queries. Furthermore serves this scheduler as a buffer. This is
particularly useful when the storage unit is overloaded.

\subsubsection{Health Monitoring Unit}

\npar The Health Monitoring Unit is the result of the tactic to detect a
fault, namely heartbeat. This component will monitor all other component's
heartbeat to see if they are still alive (i.e. not crashed). Off course it is
not unthinkable that the monitor component fails itself. Therefore this
component has to monitor itself by for example providing an extra monitor that
monitors the monitor (or a cluster of monitors). Futhermore is it often
necessary (depending on the failing component) to notify a ReMeS operator, this
functionality is also present in this unit.

\subsubsection{MeasurementsStorage}

\npar This component is responsible for all storage of measurements (and
measurements only). It receives trames from the Scheduler For
MeasurementsStorage and notifies the Scheduler For Anomaly Detection when a
measurement trame is available.

\subsubsection{Scheduler For Anomaly Detection}

\npar When the MeasurementsStorage has stored a new measurement, this scheduler
is notified and fetches the freshly stored measurement (by sending a read query
to the Scheduler For MeasurementsStorage). Analogous to the Scheduler For
MeasurementsStorage this scheduler serves as a buffer to prevent overloading on
the Anomaly Detection Unit. Once again different scheduling policies can be
turned on.

\npar For alarm trames, the situation differs a little from the measurement
trame's one. These alarms are sent directly towards this scheduler. Once again
depending on the current policy priorities can be toggled. One wants to off
course give priority to alarm trames over regular measurements. 

\npar After this scheduling phase the trames are sent to the anomaly detection
unit for further processing.

\subsubsection{Notification Unit}

\npar This module is contacted by the Anomaly Detection Unit. When the latter
detects an anomaly in the usage of one of the utilities of a customer or
receives a (non false) alarm, then that customer (and possibly the emergency
services) needs to notified. This is the responsibility of the Notification
Unit. The retrieval of the contact details is also the responsibility of this
component.

\subsubsection{Anomaly Detection Unit}

\npar The Anomaly Detection Unit is responsible for running the algorithms to
discover anomalies. It receives trames from the Scheduler For Anomaly
Detection so it can process them. After receiving such a trame, additional
trames are fetched by sending a read query to the Scheduler For
MeasurementsStorage. These additional trames are from the same customer or
utility company because the detection algorithms off course work based on data
sets instead of single trames. Notice that there are multiple instances of this
Anomaly Detection Unit. This allows load balancing, cf. P2.

\npar The task of this unit is the managing of all these Anomaly Detection
Instances. This includes monitoring the load of all the instances, performing
the read queries and distributing the resulting trames. Upon detecting an
anomaly two possible actions (or both) can be undertaken. The first is sealing a
valve if it is a severe leak (this action is represented by the dependency
between the scheduler For Outbound Communication and the anomaly detection). The
second is notifying the approriate parties (the customer and/or the emergency
services) by contacting the Notification Unit.

\subsubsection{Scheduler For Outbound Communication}

\npar The Scheduler For Outbound Communication has as duty the scheduling of
trames which are sent to remote modules. There is a need for scheduling because
control trames to shut a valve need to reach the specified module within certain
time constraints according to P1. This scheduling can again be realized by the
use of different policies.

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it1/interfaces}

\npar In this section each interface is explained in terms of the components
which use and/or offer it together with information about what is exchanged. For
detailed information with reference to the specific methods the interfaces
implement, we refer to the interface catalog, see appendix
\ref{chap:interface-catalog}.

\subsubsection{InboundCommAPI}

\npar This interface lies in between ReMeS (more precisely the Remote Module
Communication Unit) and the remote module(s). Remote modules send measurements
and alarm trames towards ReMeS through this interface.

\subsubsection{OutboundCommAPI}

\npar The \interface{OutboundCommAPI} is offered by the Remote Module
Communication Unit and is used by the Scheduler For Outbound Communication. Its
purpose is to provide outgoing communication, i.e. from ReMeS (the Remote Module
Communication Unit) to the remote module(s).

\subsubsection{MeasurementsSchedulerAPI}

\npar The Scheduler For MeasurementsStorage offers this interface towards the
Anomaly Detection Unit and the Remote Module Communication Unit. Both of the
latter parties can schedule so called CRUD (Create, Read, Update and Delete)
queries on this component through its interface.

\subsubsection{MeasurementsStorageAPI}

\npar This is the interface of the actual storage unit. It is invoked by the
Scheduler For MeasurementsStorage to execute queries which were scheduled.  

\subsubsection{AnomalyDetectionAPI}

\npar The \interface{AnomalyDetectionAPI} interface offers functionality to
effectively analyze a given trame. This interface is used by the Scheduler For
Anomaly Detection.

\subsubsection{ADSchedulerAPI}

\npar The \interface{ADSchedulerAPI} is offered by the Scheduler For
Anomaly Detection and is used by the Remote Module Communication Unit and the
MeasurementsStorage. Through the use of this interface both of the two latter
components can schedule commands to be (eventually) executed by the Anomaly
Detection Unit.

\subsubsection{NotificationAPI}

\npar This interface lies in between the Anomaly Detection Unit and the
Notification Unit. The methods it offers can be invoked to send alarms towards
customers and/or emergency services.

\begin{figure}[H]
	\begin{centering}
		\includegraphics[width=1.4\textwidth,angle=90]{figs/add-it1-interfaces.pdf}
		\caption{Overview of the interfaces and components in the ReMeS
		System}
		\label{fig:it1/interfaces}
	\end{centering}
\end{figure}

\subsubsection{CustomerProfileAPI}

\npar This is an interface offered by the Shared Repository towards the
Notification Unit for the flow of contact details for customers.

\subsubsection{RMConfigurationAPI}

\npar The Shared Repository offers this interface towards the Remote Module
Communication Unit to exchange information about remote module configurations.

\subsubsection{AlarmAPI}

\npar The \interface{AlarmAPI} lies in between the Shared Repository and the
Anomaly Detection Unit. It serves to support the information flow with regards
to alarms.

\subsection{Step 5: Verify and refine}
\label{add:it1/verification}

\npar In this step, we verify that that the element decomposition thus far meets
the functional requirements and quality attribute requirements. Also, child
elements are prepared for further decomposition.

\npar Three things have to be verified. First, we will verify that all
functional requirements and quality attribute requirements of the parent element
have been allocated to one or more child elements in the decomposition.
Secondly, all responsibilities that were assigned to child modules are
translated into functional requirements for the individual items and finally,
quality attribute scenarios for individual child elements are refined if
necessary.

\npar Below, we composed a list of all child elements and their allocated use
cases and quality attribute scenarios. For every item, it is indicated whether
the requirement is split, delegated or derived. Also, for split and derived
elements a short description is provided.

\begin{itemize}
	\item Remote Module Communication Unit
	\begin{itemize}
	  	\item UCy: Retrieve remote module protocol (derived). Gets the protocol in
	  	order to select the right translator to be able to communicate with the device. 
		\item UC7: Send trame to remote device (delegated). 
		\item UC8': Send measurement (split). Acknowledgment of trames and activation
		of modules.
		\item UC13': Send alarm (split). Acknowledgement of alarms.
		\item Av2': Missing measurements (split). The communication unit will monitor
		the interarrival times of trames and will detect missing measurement trames.
		Also, the health of the component is being monitored.
		\item M1': Dynamic pricing (split). The communication module should support
		new meters in the near future. 
		\item M2': Fine-grained metering for enterprises (split). The communication
		module should support new meters (i.e. secondary meters) in the near future. 
		\item M3': Decentralized electricity generation (split). The communication
		module should support new meters (i.e. production meters) in the near future.
	\end{itemize}
	\item Scheduler For MeasurementsStorage
	\begin{itemize}
		\item P3': Requests to the measurement database (split). Queries of different
		types have different priorities.
		\item UC8': Send Measurement (split). 
		\item UC17': Perform Research (split). 
	\end{itemize}
	\item Measurements Storage
	\begin{itemize}
		\item Av1': Measurement database failure (split). Replicate the database.
	  	\item P3': Requests to the measurement database (split). Load balancing.
	\end{itemize}
	\item Scheduler For Anomaly Detection 
	\begin{itemize}
		\item P1' : Timely closure of valves (split). Make sure alarms are processed
		in time. 
	  	\item P2': Anomaly Detection (split). Make sure measurements are processed
	  	in time. 
		\item UCz: Determine the operational mode (derived). Determine the load in
		order to utilize the right policy.
	\end{itemize}
	\item Anomaly Detection Unit
	\begin{itemize}
		\item P2': Anomaly Detection (split). Parallellize anomaly detection.
		\item UC10: Anomaly Detection (delegated). Perform the actual anomaly
		detection.
	\end{itemize}
	\item Notification Unit
	\begin{itemize}
		\item UC9: Notify Customer (delegated). Notify customers, alarm recipients,
		call center and the emergency services. 
	  	\item UCx: Retrieve customer from a deviceId (derived). Gets the customer's
	  	profile based on a received trame (by using the device's identification)
	\end{itemize}
	\item Scheduler for Outbound Communication
	\begin{itemize}
	  \item P1': Timely closure of valves (split). Make sure that control trames
	  that originated from alarms are processed with high priority. 
	\end{itemize}
	\item Health Monitoring Unit
	\begin{itemize}
		\item Av1': Measurement database failure (split). Notify ReMeS operators. 
		\item Av2': Missing measurements (split). Notify ReMeS operators.
	\end{itemize}
	\item Other functionality
	\begin{itemize}
	  	\item Av3: Third Party Billing Service failure (delegated).
	  	\item M1': Dynamic pricing (split). All modifiable functionality regarding
	  	billing.
	  	\item M2: Fine-grained metering for enterprises (delegated).
	  	\item M3': Decentralized electricity generation (split). The B2B front end.
	  	\item UC1: Log in (delegated).
	  	\item UC2: Log off (delegated).
	  	\item UC3: Register customer (delegated).
	  	\item UC4: Unregister customer (delegated).
	  	\item UC5: Associate device to customer (delegated).
	  	\item UC6: Customize customer profile (delegated).
	  	\item UC11: Operate remote actuator remotely (delegated).
	  	\item UC12: Set alarm recipients (delegated).
	  	\item UC14: Request consumption predictions (delegated).
	  	\item UC15: Generate invoice (delegated).
	  	\item UC16: Mark invoice paid (delegated).
	  	\item UC17: Perform research (delegated).
	\end{itemize}
\end{itemize}
