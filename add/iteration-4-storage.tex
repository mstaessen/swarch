\section{Iteration 4: Decomposition of the Storage Unit}
\label{add:it4}

\subsection{Step 1: Identify candidate drivers}
\label{add:it4/drivers}

\npar This iteration is driven by

\begin{itemize}
	\item Av1: Measurement database failure. The measurements database should be up
	and running 99.9\% of all time. 
	\item Av2': Missing measurements. A failing internal communication component
	should be detected autonomously. 
  	\item P3': Requests to the measurement database. The requests should be
  	handled within a bounded time. 
\end{itemize}

\subsection{Step 2: Choose design concepts}
\label{add:it4/concepts}

\subsubsection{Tactics}
\label{add:it4/tactics}

\paragraph{Availability} 

\npar Av1 states that a 99.9\% uptime must be realized. In order to guarantee
this, three things must be taken into consideration. It should be able to detect
the problem, there should be a way to fix the problem and last but certainly not
least, there should be preventive measures.

\npar There are many alternatives to address availability. The most frequently
used ones are active redundancy, passive redundancy and spare. The main
criterion to select one of these is the downtime of the system. For every
scheme, the downtimes are respectively in the order of milliseconds, seconds and
minutes. An uptime of 99.9\% corresponds to 0.72 hours (= 43.2 minutes) of
permitted downtime on a monthly basis. This number reveals potential problems
for when a spare is used because there can be only less than 10 failures a
month. For this reason, use of spares is eliminated.

\npar The difference between active and passive replication is rather subtle.
In an active replication scheme, the system will recover faster then in a
passive replication scheme but all replicas should be in a consistent
state. This will increases communication overhead in comparison with the
passive replication scheme.

\npar On the other hand, the active replication scheme can also provide load
balancing for read-only queries. If one replica has a lower load than any other,
that replica can be used to process the query. Because of this advantage, the
active replication scheme is selected.

\subsubsection{Design Patterns}
\label{add:it4/patterns}

\paragraph{Replicated Component Group} 

\npar To make the data highly available, the database will be replicated. This
can be achieved by using the \emph{Replicated Component Group} design pattern.
The database access will be replaced with a front-end interface that replicates
all write queries to all the replicas and load balances read queries over all
instances.

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it4/elements}

\npar A FrontEnd will provide an interface to execute queries on the
measurements database. This database will be replicated among different nodes,
called TrameStorageInstances. The FrontEnd will coordinate interaction between
all instances and the FrontEnd.

% TODO Figure

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it4/interfaces}

\subsubsection{TrameStorageFrontEnd}

\npar The TrameStorageFrontEnd component provides an interface
\interface{TrameStorageAPI} to the Trame Storate Scheduler. This interface
contains one method \method{execute(Query, Callback) : void} that offers a way
to execute a query on the trames database. The Query is encapsulated as an
object and a Callback is provided to forward the results to whenever the query
is executed.

\subsubsection{TrameStorageInstance}

\npar The TrameStorageFrontEnd contains no data. It fetches the data from one
or more TrameStorageInstances through the \interface{TrameQueryAPI}
interface. This interface contains a single method \method{execute(Query) :
Result}. The result of the query is encapsulated in a Result object and it is
a synchronous method call.

\npar The database instances itself provide an interface
\interface{StorageInstance} that can be used to access managerial data (for
instance the current load and other information the front end might need to
know to delegate queries to the instances).

\npar Every StorageInstance also provides an interface \interface{TrameQuery}.
This interface is used to run queries on the database. 


\begin{figure}[H]
	\begin{centering}
		%\includegraphics[width=0.8\textwidth]{figs/add/it4/interfaces.pdf}
		\caption{Overview of the interfaces and components of the Storage Component.}
		\label{fig:it4/interfaces}
	\end{centering}
\end{figure}

\subsection{Step 5: Verify and refine}
\label{add:it4/verification}

% TODO