\section{Iteration 2: Decomposition of the Remote Module Communication Unit}
\label{add:it2}

\subsection{Step 1: Identify candidate drivers}
\label{add:it2/drivers}

\npar In the previous iteration, four requirements (UC7', Av2', M1' and M3')
were assigned to the remote module communication unit and 2 use cases were
created. The three quality attributes will form the drivers for this iteration.

\subsection{Step 2: Choose design concepts}
\label{add:it2/concepts}

\subsubsection{Tactics}
\label{add:it2/tactics}

\paragraph{Modifiability}

\npar When opting for a modifiable solution 3 main (groups) of tactics can be
used: localize modifications, prevent ripple effect and defer binding time.
Two tactis are picked from the first group, namely abstraction of common
services and anticipate expected changes.

\npar To prevent rippling effects three tactics are employed. The first one,
probably the most important one, is the hiding of information through the use of
interfaces. Furthermore are communication paths restricted and an intermediary
will be used.

\paragraph{Availability}

%TODO: hoe wordt Av2' eigenlijk gerealiseerd in deze module ? :s Was dat heel
% die heartbeat kwestie ?

\subsubsection{Design Patterns}
\label{add:it2/patterns}

\npar To realize the modifiability tactics and allow the coverage of UC7', the
\emph{Message Translator} pattern is selected. The translator acts an
intermediary between the remote module and ReMeS and all information remains
hidden behind a simple interface. 

\npar To push this information hiding even further a modified version of the
\emph{Resource Pool} pattern is used. This will be enlightened in the next
section.

%TODO: misschien is dit niet helemaal waar, want resource pool is meer op
% performantie gericht.

\npar \emph{Publisher - Subscriber} %TODO

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it2/elements}

\begin{figure}[H]
	\begin{centering}
		% TODO
		%\includegraphics[width=0.6\textwidth]{figs/decomposition/rm-comm-unit/decomposition.pdf}
		\caption{The decomposition of the remote module communication unit. Iteration
		2}
		\label{fig:add/it2/decomposition}
	\end{centering}
\end{figure}

\npar The remote module communication unit has three main components: Input
Translator, Output Translator, Translator Pool, Event Channel, Deadline Monitor
and Trame Consumer. Each of them will be discussed below. As one can see in
diagram \ref{fig:add/it2/decomposition} there are only two communication paths
in the system, one for incoming communication and one for outgoing. In this way
another tactic is realized, namely the restriction of communication paths.

\npar In the previous section there was the mentioning of a modified version of
the \emph{Resource Pool} pattern. One can see this pattern in the usage of the
translator pool. The translator pool component itself acts as a sort of manager
of the pool and handles incoming requests for translators based on a
certain module. The difference with the original pattern lies in the 
diversity of the translators. Each translator is different whereas the
resources normally should all be equal. 

\subsubsection{Input Translator}

\npar The input translator has as duty the translation of incoming (raw) trames
into objectified trames. Therefore it must know what the incoming data format
is. To realize this, it has a translator pool at its disposal where, based on
the module (type) a translator can be fetched. The translated trame is provided
with extra information concerning the customer (i.e. the owner of the module where the
trame came from). When the trames are translated they are published on the event
channel for all interested parties.

\subsubsection{Output Translator}

\npar This component is analogous to the input translator off course. This
component retrieves the right translator from the pool based on the module
where the incoming trame should be send to. It is important to notice that all
outgoing communication towards remote modules goes through this module.

\subsubsection{Translator Pool}

\npar The translator pool acts as the manager for the pool and all requests from
both the translators will pass through this component. 

\subsubsection{Event Channel}

\npar The event channel is the communication entity where publishers can publish
events on and subscribers can subscribe on.

\subsubsection{Deadline Monitor}

\npar The responsibility of this process is the monitoring of all bypassing
measurements and guaranteeing that a missing measurement is detected within the
demanded time limits. This monitor is subscribed to the event channel to receive
trames. To guarantee these limits the monitor keeps a table with expected
arrival times of all remote devices which is frenquently checked. Notice that to
protect from failures, this table is made persistent. When a deadline is
exceeded this is stored in the corresponding database. When a certain number of
deadline violations is reached a ReMeS operator is notified.

\subsubsection{Trame Consumer}

\npar The trame consumer is a simple forwarding unit which is subscribed to the
event channel and receives all trames which are published on it. It simply
forwards all trames to the storage scheduler.

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it2/interfaces}

\subsubsection{Input Translator}

\paragraph{} %TODO: naam en parameter van de receive

\npar The incoming translator offers one method \method{receiveTrame(\ldots)}
which is invoked by remote modules whenever they want to send a trame towards
ReMeS. 
% The translator demands three interfaces for operating correctly. First of
% all it needs a \interface{Translator} interface to retrieve the correct
% translator. It also needs an \interface{TrameChannel} 

\subsubsection{Output Translator}

\paragraph{}%TODO: naam en parameter van de send

\npar The output translator also offers only one method, \method{send(\ldots)}.
This method can be invoked by components who need to communicate with one or
more remote modules.

\subsubsection{Translator Pool}

\paragraph{Translator}

\npar The translator pool interface offers one method,
\method{GetTranslatorFor(RemoteDevice)}. This method does nothing else than
return the correct translator for the given remote device (there can be
differences between remote module types, communication channels, etc.).

\subsubsection{Trame Event Channel}

\paragraph{TrameChannel}

\npar This interface offers two methods as prescribed by the \emph{Publisher -
Subriber} pattern, \method{publish(event)} and \method{subscribe(filter)}.

\subsubsection{Deadline Monitor}

\npar This unit offers no interface. 

\subsubsection{Trame Consumer}

\npar This unit neither offers an interface.

% Furthermore does it need a \method{scheduleForStorage(\ldots)} to push the
% freshly translated trame further into ReMeS.
%TODO: hoe zit het met de interfaces tussen de pool en zijn instances ?

\subsection{Step 5: Verify and refine}
\label{add:it2/verification}

\npar All the drivers were resolve so no futher decomposition of any of these
modules has to take place because there are no more requirements to divide
amongst the components. 
