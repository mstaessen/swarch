\section{Iteration 2: Decomposition of the Remote Module Communication Unit}
\label{add:it2}

\subsection{Step 1: Identify candidate drivers}
\label{add:it2/drivers}

\npar In the previous iteration, four requirements (UC7', Av2', M1' and M3')
were assigned to the remote module communication unit and 2 use cases were
created. The three quality attributes will form the drivers for this iteration.

\subsection{Step 2: Choose design concepts}
\label{add:it2/concepts}

\subsubsection{Tactics}
\label{add:it2/tactics}

\paragraph{Modifiability}

\npar When opting for a modifiable solution 3 main (groups) of tactics can be
used: localize modifications, prevent ripple effect and defer binding time.
Two tactis are picked from the first group, namely abstraction of common
services and anticipate expected changes.

\npar To prevent rippling effects three tactics are employed. The first one,
probably the most important one, is the hiding of information through the use of
interfaces. Furthermore are communication paths restricted and an intermediary
will be used.

\paragraph{Availability}

\npar The chosen availability tactic is detection, more specific the heartbeat
mechanism.

\subsubsection{Design Patterns}
\label{add:it2/patterns}

\npar To realize the modifiability tactics and allow the coverage of UC7', the
\emph{Message Translator} pattern is selected. The translator acts an
intermediary between the remote module and ReMeS and all information remains
hidden behind a simple interface. 

\npar To push this information hiding even further a modified version of the
\emph{Resource Pool} pattern is used. This will be enlightened in the next
section.
%TODO: misschien is dit niet helemaal waar, want resource pool is meer op
% performantie gericht.

\npar Finally the \emph{Publisher - Subscriber} pattern is used to allow
multiple components to receive trames in parallel. 

\subsection{Step 3: Instantiate architectural elements and allocate responsibilities}
\label{add:it2/elements}

\begin{figure}[H]
	\begin{centering}
		% TODO
		%\includegraphics[width=0.6\textwidth]{figs/decomposition/rm-comm-unit/decomposition.pdf}
		\caption{The decomposition of the remote module communication unit. Iteration
		2}
		\label{fig:add/it2/decomposition}
	\end{centering}
\end{figure}

\npar The remote module communication unit has three main components: Input
Translator, Output Translator, Translator Pool, Event Channel, Deadline Monitor
and Trame Consumer. Each of them will be discussed below. As one can see in
diagram \ref{fig:add/it2/decomposition} there are only two communication paths
in the system, one for incoming communication and one for outgoing. In this way
another tactic is realized, namely the restriction of communication paths.

\npar In the previous section there was the mentioning of a modified version of
the \emph{Resource Pool} pattern. One can see this pattern in the usage of the
translator pool. The translator pool component itself acts as a sort of manager
of the pool and handles incoming requests for translators based on a
certain module. The difference with the original pattern lies in the 
diversity of the translators. Each translator is different whereas the
resources normally should all be equal. 

\subsubsection{Input Translator}

\npar The input translator has as duty the translation of incoming (raw) trames
into objectified trames. Therefore it must know what the incoming data format
is. To realize this, it has a translator pool at its disposal where, based on
the module (type) a translator can be fetched. The translated trame is provided
with extra information concerning the customer (i.e. the owner of the module where the
trame came from). When the trames are translated they are published on the event
channel for all interested parties.

\subsubsection{Output Translator}

\npar This component is analogous to the input translator off course. This
component retrieves the right translator from the pool based on the module
where the incoming trame should be send to. It is important to notice that all
outgoing communication towards remote modules goes through this module.

\subsubsection{Translator Pool}

\npar The translator pool acts as the manager for the pool and all requests from
both the translators will pass through this component. 

\subsubsection{Event Channel}

\npar The event channel is the communication entity where publishers can publish
events on and subscribers can subscribe on.

\subsubsection{Deadline Monitor}

\npar The responsibility of this process is the monitoring of all bypassing
measurements and guaranteeing that a missing measurement is detected within the
demanded time limits. This monitor is subscribed to the event channel to receive
trames. To guarantee these limits the monitor keeps a table with expected
arrival times of all remote devices which is frenquently checked. Notice that to
protect from failures, this table is made persistent. When a deadline is
exceeded this is stored in the corresponding database. When a certain number of
deadline violations is reached a ReMeS operator is notified. Notice that this
component is in fact the realization of the heartbeat tactic. 

\subsubsection{Trame Consumer}

\npar The trame consumer is a simple forwarding unit which is subscribed to the
event channel and receives all trames which are published on it. It simply
forwards all trames to the storage scheduler.

\subsection{Step 4: Define interfaces for instantiated elements}
\label{add:it2/interfaces}

\subsubsection{Input Translator}

\paragraph{InputTrame} %TODO: parameter van de receive

\npar this interface was already discussed in iteration 1, see section
\ref{add:it1/interfaces}.

\subsubsection{Output Translator}

\paragraph{OutputTrame}

\npar this interface was already discussed in iteration 1, see section
\ref{add:it1/interfaces}.

\subsubsection{Translator Pool}

\paragraph{TranslatorManager}

\npar The translator pool interface offers one method,
\method{GetTranslatorFor(RemoteDevice) : Translator}. This method does nothing
else than return the correct translator for the given remote device (there can be
differences between remote module types, communication channels, etc.).

\paragraph{Translator} %TODO return parameters van translate methodes

\npar Each of the different translators implements the \interface{Translator}
translator interface. This interface includes two methods:
\method{translateFromDevice(RemoteModule)} and
\method{translateToDevice(RemoteModule)}. The former serves as translate method
for the input translator and vice versa for the latter one.

\subsubsection{Trame Event Channel}

\paragraph{TrameChannel} %TODO parameter en return type van publish methode
% (moet dezelfde zijn als het return type van translateFromDevice)

\npar This interface offers two methods as prescribed by the \emph{Publisher -
Subriber} pattern, \method{publish(event)} and \method{subscribe(Filter) :
Void}.

\subsubsection{Deadline Monitor}

\paragraph{TrameNotifiable}

\npar This interface complements the \interface{TrameChannel} interface. When a
component is subscribed to a certain event flow, the channel has to be able to
notify the component when a new event is available. Therefore this interface
offers a \method{notify() : Void}.

\subsubsection{Trame Consumer}

\npar This unit offers the exact same interface as the deadline monitor.

%TODO: hoe zit het met de interfaces tussen de pool en zijn instances ?

\subsection{Step 5: Verify and refine}
\label{add:it2/verification}

\npar All the drivers were resolved so no futher decomposition of any of these
modules has to take place because there are no more requirements to divide
amongst the components. 
